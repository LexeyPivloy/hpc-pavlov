
<div>
    <h1>Сумма элементов массива</h1>
    <p>В таблице ниже приведены значения замеров времени для суммы элементов векторов в зависимости от количества этих элементов. Были проведены эксперименты с использованием библиотеки numpy(работает на CPU, и скорее всего на нем и параллелит), cupy(работает также как numpy, только на GPU), numba(позволяет написать код для python для выполнения поставленной задачи и задавать количество thread'ов и block'ов). А так же присутствует реализация ядра на C++ (столбец в таблице: gpu) и время работы без распаралеливания (столбец в таблице: cpu)</p>
    <p>Последние два столбца показывают ускорение работы программы с использованием ядра на C++ относительно однопоточной реализации (acc (gpu>cpu)) и библиотеки numpy (acc (gpu>numpy))</p>
</div>



|       size |       cpu |     numpy |      cupy |     numba |       gpu |   acc (gpu>cpu) |   acc (gpu>numpy) |
|-----------:|----------:|----------:|----------:|----------:|----------:|----------------:|------------------:|
|   1000     | 0.0001298 | 2.5e-05   | 5.28e-05  | 0.0002506 | 2.64e-05  |      4.91667    |         0.94697   |
|   5000     | 0.0006778 | 2.84e-05  | 7.36e-05  | 0.0001613 | 3.53e-05  |     19.2011     |         0.804533  |
|  20000     | 0.0057376 | 6.51e-05  | 7.92e-05  | 0.0001522 | 3.4e-05   |    168.753      |         1.91471   |
| 100000     | 0.0254757 | 0.0001687 | 8.36e-05  | 0.000164  | 3.71e-05  |    686.677      |         4.54717   |
| 400000     | 0.0706216 | 0.0004467 | 6.71e-05  | 0.0001282 | 5.63e-05  |   1254.38       |         7.93428   |
| 700000     | 0.120534  | 0.0008332 | 0.0001299 | 0.0002176 | 3.01e-05  |   4004.45       |        27.6811    |
|      1e+06 | 0.158115  | 0.0010956 | 7.19e-05  | 0.0001302 | 2.81e-05  |   5626.86       |        38.9893    |


<h3><i>Вывод</i>: распараллеливание на gpu (а особенно реализация ядра на C++) отлично справляется с поставленной задачей </h3>

![](https://github.com/LexeyPivloy/hpc-pavlov/blob/main/static/nerd-nerdy.gif)